<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="apple-touch-icon" sizes="180x180" href="./ico/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./ico/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./ico/favicon-16x16.png">
    <link rel="manifest" href="./ico/site.webmanifest">
    <title>Nebu zap</title>
    <!-- Carga de Tailwind CSS para estilos básicos y responsivos -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Oculta barras de desplazamiento */
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Fondo oscuro */
            color: #e0e0e0;
        }
        canvas {
            display: block; /* Elimina el margen inferior por defecto del canvas */
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0; /* Asegura que el canvas esté detrás de la UI */
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1; /* Asegura que la UI esté encima del canvas */
            background-color: rgba(0, 0, 0, 0.5); /* Superposición semitransparente */
            transition: opacity 0.5s ease-in-out; /* Transición suave para ocultar/mostrar */
        }
        .control-panel {
            background: rgba(30, 30, 50, 0.35);
            backdrop-filter: blur(8px) saturate(180%);
            -webkit-backdrop-filter: blur(8px) saturate(180%);
            border-radius: 1rem;
            border: 1px solid rgba(255,255,255,0.18);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 90%;
            width: 500px;
            padding: 1rem;
        }
        .control-panel.glass {
            /* Eliminado: revertido a estilo original */
        }
        .btn {
            background-color: #0f3460;
            color: white;
            padding: 0.4rem 0.9rem;
            border-radius: 0.4rem;
            border: none;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin: 0.25rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
            opacity: 0.85;
        }
        .btn:hover {
            background-color: #16213e;
            transform: translateY(-1px);
            opacity: 1;
        }
        .btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
        }
        input[type="file"] {
            margin-top: 1rem;
            padding: 0.5rem;
            border: 1px solid #0f3460;
            border-radius: 0.5rem;
            background-color: #2e2e4a;
            color: white;
            width: 80%; /* Ajuste para mejor visualización en móvil */
            max-width: 300px; /* Limitar ancho */
        }
        input[type="range"] {
            width: 120px;
            margin-top: 0.5rem;
            -webkit-appearance: none;
            height: 6px;
            background: #0f3460;
            border-radius: 4px;
            outline: none;
            opacity: 0.6;
            transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #e94560;
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #e94560;
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        #message-box {
            background: rgba(233, 69, 96, 0.35);
            backdrop-filter: blur(8px) saturate(180%);
            -webkit-backdrop-filter: blur(8px) saturate(180%);
            color: white;
            padding: 1rem;
            border-radius: 0.7rem;
            border: 1px solid rgba(255,255,255,0.18);
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: none;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.22);
            text-align: center;
        }

        /* Estilos para los controles de audio sutiles */
        #subtle-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10; /* Encima del canvas, debajo de la UI principal */
            background: rgba(30, 30, 50, 0.35);
            backdrop-filter: blur(8px) saturate(180%);
            -webkit-backdrop-filter: blur(8px) saturate(180%);
            border-radius: 1rem;
            border: 1px solid rgba(255,255,255,0.18);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 90%;
            width: 500px;
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 1rem; /* Espacio entre elementos */
            transition: opacity 0.5s ease-in-out;
            opacity: 1; /* Siempre visible */
            pointer-events: auto; /* Permite clics */
        }

        #subtle-controls .btn {
            padding: 0.6rem 1rem; /* Botones más pequeños */
            font-size: 0.9rem;
            margin: 0; /* Eliminar margen extra */
            background: rgba(30, 30, 50, 0.35);
            backdrop-filter: blur(6px) saturate(180%);
            -webkit-backdrop-filter: blur(6px) saturate(180%);
            border-radius: 0.7rem;
            border: 1px solid rgba(255,255,255,0.18);
            box-shadow: 0 4px 12px rgba(0,0,0,0.18);
        }

        #subtle-controls input[type="range"] {
            width: 120px; /* Ancho fijo para el slider */
            margin: 0;
            background: rgba(30, 30, 50, 0.25);
            backdrop-filter: blur(6px) saturate(180%);
            -webkit-backdrop-filter: blur(6px) saturate(180%);
            border-radius: 0.7rem;
            border: 1px solid rgba(255,255,255,0.18);
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
            color: #e0e0e0;
        }

        #subtle-controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fff;
            border: 1px solid rgba(255,255,255,0.7);
            box-shadow: 0 2px 6px rgba(0,0,0,0.18);
            cursor: pointer;
        }

        #subtle-controls input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fff;
            border: 1px solid rgba(255,255,255,0.7);
            box-shadow: 0 2px 6px rgba(0,0,0,0.18);
            cursor: pointer;
        }

        /* Mostrar los controles sutiles cuando sea necesario */
        #subtle-controls.visible {
            opacity: 1;
            pointer-events: auto; /* Habilita clics cuando está visible */
        }
        @media (max-width: 600px) {
            #subtleVolumeControl {
                display: none !important;
            }
            #track-list {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: auto !important;
                width: 100vw !important;
                flex-direction: row !important;
                align-items: center !important;
                justify-content: flex-start !important;
                gap: 0.7rem !important;
                z-index: 30 !important;
                padding: 0.7rem 0.2rem 0.2rem 0.2rem !important;
                overflow-x: auto !important;
                background: none !important;
            }
            #track-list > div {
                text-align: center !important;
                margin: 0 !important;
                flex: none !important;
            }
        }
    </style>
</head>
<body>
    <div id="message-box"></div>
    <!-- Reproductor nativo oculto para móviles -->
    <audio id="nativeAudioPlayer" style="display:none;" controls preload="auto"></audio>
    <!-- Eliminado el panel central -->

    <!-- Controles de audio sutiles -->
    <div id="subtle-controls" style="display: flex; flex-direction: column; align-items: center;">
        <div class="flex items-center gap-2 w-full mb-2 justify-center" style="width:100%; justify-content:center;">
            <span id="audioCurrentTime" style="font-size:0.8em;min-width:40px;text-align:right;">0:00</span>
            <input type="range" id="audioSeekBar" min="0" max="100" value="0" step="0.01" style="flex:1; max-width:220px;">
            <span id="audioDuration" style="font-size:0.8em;min-width:40px;text-align:left;">0:00</span>
        </div>
        <div style="display:flex; align-items:center; gap:1rem; justify-content:center;">
            <button id="subtlePrevAudioButton" class="btn" title="Anterior"><i class="fa-solid fa-backward-step"></i></button>
            <button id="subtlePlayPauseButton" class="btn" title="Reproducir/Pausar"><i class="fa-solid fa-play"></i></button>
            <button id="subtleStopButton" class="btn" title="Detener"><i class="fa-solid fa-stop"></i></button>
            <button id="subtleNextAudioButton" class="btn" title="Siguiente"><i class="fa-solid fa-forward-step"></i></button>
            <button id="showMobileTrackListButton" class="btn" title="Elegir tema" style="display:none;"><i class="fa-solid fa-list"></i></button>
            <div class="flex items-center gap-2">
                <input type="range" id="subtleVolumeControl" min="0" max="1" step="0.01" value="0.5">
            </div>
        </div>
    </div>

    <!-- Lista vertical de temas (solo desktop) -->
    <div id="track-list" style="position: fixed; bottom: 20px; right: 20px; z-index: 20; display: flex; flex-direction: column; align-items: flex-end; gap: 0.5rem;">
        <!-- Los temas se renderizan dinámicamente -->
    </div>
    <!-- Modal central para lista de temas en mobile -->
    <div id="mobile-track-list-modal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(30,30,50,0.85); z-index:100; justify-content:center; align-items:center;">
        <div id="mobile-track-list" class="glass" style="background:rgba(30,30,50,0.35); backdrop-filter: blur(8px) saturate(180%); -webkit-backdrop-filter: blur(8px) saturate(180%); border-radius:1rem; box-shadow:0 10px 20px rgba(0,0,0,0.3); padding:2rem 1.2rem; max-width:90vw; max-height:80vh; overflow-y:auto; display:flex; flex-direction:column; align-items:center; gap:1rem;"></div>
        <button id="closeMobileTrackList" style="position:absolute; top:18px; right:18px; background:#e94560; color:#fff; border:none; border-radius:50%; width:38px; height:38px; font-size:1.3rem; box-shadow:0 2px 8px rgba(0,0,0,0.18); cursor:pointer;">&times;</button>
    </div>

    <!-- Carga de Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Carga de OrbitControls para interactividad de la cámara -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script type="module">
        // Renderizar la lista vertical de temas
        function renderTrackList() {
            const trackList = document.getElementById('track-list');
            const showMobileTrackListButton = document.getElementById('showMobileTrackListButton');
            // Detectar si es mobile
            const isMobile = window.innerWidth <= 600 || /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent);
            // En mobile, ocultar la lista superior y mostrar solo el botón
            if (isMobile) {
                trackList.style.display = 'none';
                showMobileTrackListButton.style.display = 'inline-block';
            } else {
                trackList.style.display = 'flex';
                showMobileTrackListButton.style.display = 'none';
            }
            trackList.innerHTML = '';
            if (!audioFiles || audioFiles.length === 0) return;
            if (!isMobile) {
                for (let i = 0; i < audioFiles.length; i++) {
                    const item = document.createElement('div');
                    item.textContent = audioFiles[i].split('/').pop();
                    item.style.transition = 'transform 0.3s, font-size 0.3s, opacity 0.3s';
                    item.style.cursor = 'default';
                    item.style.background = 'rgba(30,30,50,0.35)';
                    item.style.backdropFilter = 'blur(6px) saturate(180%)';
                    item.style.webkitBackdropFilter = 'blur(6px) saturate(180%)';
                    item.style.borderRadius = '0.7rem';
                    item.style.border = '1px solid rgba(255,255,255,0.18)';
                    item.style.boxShadow = '0 2px 8px rgba(0,0,0,0.12)';
                    item.style.color = '#e0e0e0';
                    item.style.padding = '0.4rem 1.2rem';
                    item.style.fontSize = '0.7rem';
                    if (i === currentVisualizerIndex) {
                        item.style.transform = 'scale(1)';
                        item.style.fontSize = '1rem';
                        item.style.opacity = '1';
                        item.style.fontWeight = 'bold';
                    } else if (i === currentVisualizerIndex - 1 || (currentVisualizerIndex === 0 && i === audioFiles.length - 1)) {
                        item.style.transform = 'scale(0.9)';
                        item.style.fontSize = '0.8rem';
                        item.style.opacity = '0.7';
                    } else if (i === currentVisualizerIndex + 1 || (currentVisualizerIndex === audioFiles.length - 1 && i === 0)) {
                        item.style.transform = 'scale(0.9)';
                        item.style.fontSize = '0.8rem';
                        item.style.opacity = '0.7';
                    } else {
                        item.style.transform = 'scale(0.8)';
                        item.style.fontSize = '0.7rem';
                        item.style.opacity = '0.4';
                    }
                    // Sin acción de click
                    trackList.appendChild(item);
                }
                trackList.style.opacity = '1';
            }
        }
        // Renderizar lista de temas en modal central para mobile
        function renderMobileTrackList() {
            const mobileTrackListModal = document.getElementById('mobile-track-list-modal');
            const mobileTrackList = document.getElementById('mobile-track-list');
            mobileTrackList.innerHTML = '';
            if (!audioFiles || audioFiles.length === 0) return;
            for (let i = 0; i < audioFiles.length; i++) {
                const item = document.createElement('div');
                item.textContent = audioFiles[i].split('/').pop();
                item.style.transition = 'transform 0.3s, font-size 0.3s, opacity 0.3s';
                item.style.cursor = 'default';
                item.style.background = i === currentVisualizerIndex ? '#e94560' : 'rgba(30,30,50,0.35)';
                item.style.color = i === currentVisualizerIndex ? '#fff' : '#e0e0e0';
                item.style.borderRadius = '0.7rem';
                item.style.border = '1px solid rgba(255,255,255,0.18)';
                item.style.boxShadow = '0 2px 8px rgba(0,0,0,0.12)';
                item.style.padding = '0.7rem 2rem';
                item.style.fontSize = i === currentVisualizerIndex ? '1.1rem' : '0.9rem';
                item.style.fontWeight = i === currentVisualizerIndex ? 'bold' : 'normal';
                item.style.backdropFilter = 'blur(8px) saturate(180%)';
                item.style.webkitBackdropFilter = 'blur(8px) saturate(180%)';
                // Acción de click para cambiar de tema en mobile
                item.style.cursor = 'pointer';
                item.addEventListener('click', async () => {
                    if (i !== currentVisualizerIndex) {
                        // Detener el audio actual antes de cambiar
                        if (useNativeAudio) {
                            nativeAudioPlayer.pause();
                            nativeAudioPlayer.onended = null;
                            nativeAudioPlayer.currentTime = 0;
                        } else {
                            if (audioSource) {
                                audioSource.onended = null;
                                audioSource.stop();
                                audioSource.disconnect();
                                isPlaying = false;
                                audioStartTime = 0;
                                audioPausedAt = 0;
                            }
                        }
                        currentVisualizerIndex = i;
                        await changeVisualizer(i);
                        renderTrackList();
                    }
                    // Ocultar el modal después de seleccionar
                    document.getElementById('mobile-track-list-modal').style.display = 'none';
                });
                mobileTrackList.appendChild(item);
            }
        }
        // Mostrar/ocultar modal de lista de temas en mobile
        document.addEventListener('DOMContentLoaded', () => {
            const showMobileTrackListButton = document.getElementById('showMobileTrackListButton');
            const mobileTrackListModal = document.getElementById('mobile-track-list-modal');
            const closeMobileTrackList = document.getElementById('closeMobileTrackList');
            showMobileTrackListButton.addEventListener('click', () => {
                renderMobileTrackList();
                mobileTrackListModal.style.display = 'flex';
            });
            closeMobileTrackList.addEventListener('click', () => {
                mobileTrackListModal.style.display = 'none';
            });
            // Cerrar modal al hacer click fuera de la lista
            mobileTrackListModal.addEventListener('click', (e) => {
                if (e.target === mobileTrackListModal) {
                    mobileTrackListModal.style.display = 'none';
                }
            });
        });
        // Variables globales para Three.js
        let scene, camera, renderer, controls;
        let planeMesh; // Malla del plano principal
        let backgroundSphereMesh; // Nueva malla para la esfera de fondo
        let uniforms; // Uniforms para el shader del plano principal
        let backgroundUniforms; // Uniforms para el shader de la esfera de fondo

        // Variables globales para Web Audio API y nativo
        let audioContext;
        let analyser;
        let audioSource;
        let gainNode;
        let audioBuffer; // Almacenará el buffer de audio cargado
        let isPlaying = false;
        let useNativeAudio = false;
        const nativeAudioPlayer = document.getElementById('nativeAudioPlayer');

        // Variables de imágenes y transición (Plano Principal)
        let imageTextures = []; // Array para almacenar todas las texturas cargadas para el plano principal
        let currentTextureIndex = 0;
        let nextTextureIndex = 0;
        const TRANSITION_STATE = {
            IDLE: 0,
            FADE_OUT: 1,
            FADE_IN: 2
        };
        let transitionState = TRANSITION_STATE.IDLE;
        const transitionDuration = 1.2; // Duración total de la transición en segundos (más rápida)
        const minDisplayTime = 5.0; // Tiempo mínimo que una imagen se muestra antes de transicionar
        let lastTransitionTime = 0; // Tiempo en segundos desde el inicio de la animación

        // Elementos UI
        const messageBox = document.getElementById('message-box');

        // Referencias a los controles sutiles
        const subtleControls = document.getElementById('subtle-controls');
        const subtlePlayPauseButton = document.getElementById('subtlePlayPauseButton');
        const subtleStopButton = document.getElementById('subtleStopButton');
        const subtleVolumeControl = document.getElementById('subtleVolumeControl');

        // --- Variables para múltiples visualizadores ---
        let audioFiles = [];
        let imagesByAudio = [];
        let currentVisualizerIndex = 0;


        // Función para mostrar mensajes al usuario (reemplaza alert())
        function showMessage(message, duration = 3000) {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, duration);
        }

        // --- Configuración de Three.js ---
        function initThreeJS() {
            // 1. Escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // Color de fondo inicial

            // 2. Cámara
            camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 0, 0); // Más alejado para menos zoom inicial

            // 3. Renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 4. Controles de órbita para la cámara
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Permite un movimiento de cámara más suave
            controls.dampingFactor = 1.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 2;
            controls.maxDistance = 30;

            // 5. Luz (opcional, pero útil para ver objetos)
            const ambientLight = new THREE.AmbientLight(0x404040); // Luz ambiental suave
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            // Crear una textura por defecto (un pixel blanco) para evitar errores si no se carga una imagen
            const defaultTexture = new THREE.DataTexture(new Uint8Array([255, 255, 255, 255]), 1, 1, THREE.RGBAFormat);
            defaultTexture.needsUpdate = true;

            // --- Plano Principal (Primer Plano) ---
            const planeGeometry = new THREE.PlaneGeometry(7, 7, 100, 100); // Menos zoom: plano más pequeño

            uniforms = {
                u_time: { value: 0.0 },
                u_audioLevel: { value: 0.0 }, // Nivel de audio, de 0.0 a 1.0
                u_color1: { value: new THREE.Color(0x0f3460) }, // Color base
                u_color2: { value: new THREE.Color(0xe94560) },  // Color reactivo al audio
                u_currentTexture: { value: defaultTexture }, // Textura actual
                u_nextTexture: { value: defaultTexture },   // Textura a la que se transiciona
                u_transitionProgress: { value: 0.0 }, // Progreso de la transición (0.0 a 1.0)
                u_hasImages: { value: 0 } // 0: no hay imágenes cargadas, 1: hay imágenes
            };

            const vertexShaderPlane = `
                uniform float u_time;
                uniform float u_audioLevel;
                varying vec2 vUv;
                varying float vDisplacement;

                void main() {
                    vUv = uv;
                    // Calcula un desplazamiento basado en el tiempo y el nivel de audio
    float displacement = sin(uv.x * 10.0 + u_time * 0.5) * cos(uv.y * 10.0 + u_time * 0.5) * u_audioLevel * 0.25; // Menos deformación
                    // Aplica el desplazamiento a la posición Z de los vértices
                    vec3 newPosition = position + normal * displacement;
                    vDisplacement = displacement; // Pasa el desplazamiento al fragment shader
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                }
            `;

            const fragmentShaderPlane = `
                uniform float u_time;
                uniform float u_audioLevel;
                uniform vec3 u_color1;
                uniform vec3 u_color2;
                uniform sampler2D u_currentTexture; // Uniforme para la textura actual
                uniform sampler2D u_nextTexture;    // Uniforme para la textura siguiente
                uniform float u_transitionProgress; // Progreso de la transición
                uniform int u_hasImages; // Uniforme para indicar si hay imágenes cargadas
                varying vec2 vUv;
                varying float vDisplacement;

                // Función de ruido para distorsión más compleja
                vec2 random2(vec2 st){
                    st = vec2( dot(st,vec2(127.1,311.7)),
                              dot(st,vec2(269.5,183.3)) );
                    return -1.0 + 2.0 * fract(sin(st)*43758.5453123);
                }

                float noise(vec2 st) {
                    vec2 i = floor(st);
                    vec2 f = fract(st);

                    vec2 u = f*f*(3.0-2.0*f);

                    return mix( mix( dot( random2(i + vec2(0.0,0.0)), f - vec2(0.0,0.0) ),
                                     dot( random2(i + vec2(1.0,0.0)), f - vec2(1.0,0.0) ), u.x),
                                mix( dot( random2(i + vec2(0.0,1.0)), f - vec2(0.0,1.0) ),
                                     dot( random2(i + vec2(1.0,1.0)), f - vec2(1.0,1.0) ), u.x), u.y);
                }

                void main() {
                    vec2 uv = vUv;
                    vec2 distortedUv = uv;

                    // Distorsión de las UVs basada en el audio y el tiempo
    float audioDistortionStrength = u_audioLevel > 0.0 ? u_audioLevel * 0.12 : 0.0; // Solo si hay audio
    float timeDistortionStrength = (u_audioLevel > 0.0 ? (sin(u_time * 0.5) * 0.03 + 0.03) : 0.0); // Solo si hay audio

                    // Solo deformar si hay audio
                    if (u_audioLevel > 0.0) {
                        distortedUv.x += sin(uv.y * 20.0 + u_time * 1.5) * audioDistortionStrength;
                        distortedUv.y += cos(uv.x * 20.0 + u_time * 1.5) * audioDistortionStrength;
                        // Añadir ruido para más caos
                        distortedUv += noise(uv * 5.0 + u_time * 0.2) * (audioDistortionStrength + timeDistortionStrength);
                        // Distorsión adicional durante la transición para hacerla más caótica
                        float transitionDistortion = u_transitionProgress * (1.0 - u_transitionProgress) * 1.2;
                        distortedUv.x += sin(uv.y * 30.0 + u_time * 3.0) * transitionDistortion * 0.3;
                        distortedUv.y += cos(uv.x * 30.0 + u_time * 3.0) * transitionDistortion * 0.3;
                        distortedUv += noise(uv * 10.0 + u_time * 0.5) * (transitionDistortion * 0.7);
                    }


                    vec4 finalTextureColor;

                    if (u_hasImages == 0) { // Si no hay imágenes cargadas, usa los colores base
                        vec3 finalColor = mix(u_color1, u_color2, u_audioLevel + abs(vDisplacement));
                        gl_FragColor = vec4(finalColor, 1.0);
                    } else {
                        // Muestrear las texturas con las UVs distorsionadas
                        vec4 currentTextureColor = texture2D(u_currentTexture, distortedUv);
                        vec4 nextTextureColor = texture2D(u_nextTexture, distortedUv);

                        // Mezcla las texturas según el progreso de la transición
                        finalTextureColor = mix(currentTextureColor, nextTextureColor, u_transitionProgress);

                        // Solo colorizar si hay audio
                        if (u_audioLevel > 0.0) {
                            // Aplicar cambio de color constante y reactivo al audio
                            // Esto es una rotación de color simple basada en el tiempo y el audio
                            vec3 colorShift = vec3(
                                sin(u_time * 2.0 + u_audioLevel * 5.0),
                                cos(u_time * 2.5 + u_audioLevel * 4.0),
                                sin(u_time * 3.0 + u_audioLevel * 3.0)
                            ) * 0.2; // Ajusta la intensidad del cambio de color

                            finalTextureColor.rgb += colorShift;
                            finalTextureColor.rgb = fract(finalTextureColor.rgb); // Para que los colores se "reinicien" y cambien constantemente
                            // Mezcla el color de la textura con un factor basado en el desplazamiento geométrico
                            // Esto le da un matiz de color y hace que la distorsión geométrica sea visible en la imagen
                            finalTextureColor.rgb *= (1.0 + abs(vDisplacement) * 0.5);
                        }

                        gl_FragColor = finalTextureColor;
                    }
                }
            `;

            const shaderMaterialPlane = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShaderPlane,
                fragmentShader: fragmentShaderPlane,
                wireframe: false // Puedes probar con true para ver la malla
            });

            planeMesh = new THREE.Mesh(planeGeometry, shaderMaterialPlane);
            planeMesh.rotation.x = -Math.PI / 2; // Rota el plano para que sea horizontal
            planeMesh.scale.set(0.4, 0.4, 0.4); // Inicialmente más pequeño
            scene.add(planeMesh);

            // --- Esfera de Fondo (Segundo Plano) ---
            const backgroundSphereGeometry = new THREE.SphereGeometry(15, 64, 64); // Radio grande para que envuelva la escena
            backgroundSphereGeometry.scale(-1, 1, 1); // Invierte las normales para ver el interior de la esfera

            backgroundUniforms = {
                u_time: { value: 0.0 },
                u_audioLevel: { value: 0.0 },
                u_backgroundTexture: { value: defaultTexture }, // Textura para el fondo
                u_hasBackgroundTexture: { value: 0 }, // 0: no hay textura de fondo, 1: hay textura
                u_bgColor1: { value: new THREE.Color(0x16213e) }, // Color de fondo 1
                u_bgColor2: { value: new THREE.Color(0x0f3460) }  // Color de fondo 2 reactivo
            };

            const vertexShaderBackground = `
                uniform float u_time;
                uniform float u_audioLevel;
                varying vec2 vUv;

                void main() {
                    vUv = uv;
                    // Simple desplazamiento de vértices para la esfera de fondo
                    float displacement = sin(uv.x * 5.0 + u_time * 0.2) * cos(uv.y * 5.0 + u_time * 0.2) * u_audioLevel * 0.1;
                    vec3 newPosition = position + normal * displacement;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                }
            `;

            const fragmentShaderBackground = `
                uniform float u_time;
                uniform float u_audioLevel;
                uniform sampler2D u_backgroundTexture;
                uniform int u_hasBackgroundTexture;
                uniform vec3 u_bgColor1;
                uniform vec3 u_bgColor2;
                varying vec2 vUv;

                // Función de ruido para distorsión
                vec2 random2(vec2 st){
                    st = vec2( dot(st,vec2(127.1,311.7)),
                              dot(st,vec2(269.5,183.3)) );
                    return -1.0 + 2.0 * fract(sin(st)*43758.5453123);
                }

                float noise(vec2 st) {
                    vec2 i = floor(st);
                    vec2 f = fract(st);

                    vec2 u = f*f*(3.0-2.0*f);

                    return mix( mix( dot( random2(i + vec2(0.0,0.0)), f - vec2(0.0,0.0) ),
                                     dot( random2(i + vec2(1.0,0.0)), f - vec2(1.0,0.0) ), u.x),
                                mix( dot( random2(i + vec2(0.0,1.0)), f - vec2(0.0,1.0) ),
                                     dot( random2(i + vec2(1.0,1.0)), f - vec2(1.0,1.0) ), u.x), u.y);
                }

                void main() {
                    vec2 uv = vUv;
                    vec2 distortedUv = uv;

                    // Distorsión de las UVs para el fondo
                    float distortionStrength = u_audioLevel * 0.05 + 0.02; // Menos intenso que el primer plano
                    distortedUv.x += sin(uv.y * 15.0 + u_time * 0.5) * distortionStrength;
                    distortedUv.y += cos(uv.x * 15.0 + u_time * 0.5) * distortionStrength;
                    distortedUv += noise(uv * 3.0 + u_time * 0.1) * distortionStrength;

                    vec4 finalColor;

                    if (u_hasBackgroundTexture == 0) { // Si no hay textura de fondo personalizada
                        finalColor = vec4(mix(u_bgColor1, u_bgColor2, u_audioLevel), 1.0);
                    } else {
                        finalColor = texture2D(u_backgroundTexture, distortedUv);
                        // Aplicar un ligero cambio de color y mezcla con el audio
                        vec3 colorShift = vec3(
                            sin(u_time * 1.0 + u_audioLevel * 2.0),
                            cos(u_time * 1.2 + u_audioLevel * 1.5),
                            sin(u_time * 1.5 + u_audioLevel * 1.0)
                        ) * 0.1;
                        finalColor.rgb += colorShift;
                        finalColor.rgb = fract(finalColor.rgb);
                        finalColor.rgb = mix(finalColor.rgb, mix(u_bgColor1, u_bgColor2, u_audioLevel), 0.2); // Mezcla sutil con colores base
                    }
                    gl_FragColor = finalColor;
                }
            `;

            const shaderMaterialBackground = new THREE.ShaderMaterial({
                uniforms: backgroundUniforms,
                vertexShader: vertexShaderBackground,
                fragmentShader: fragmentShaderBackground,
                wireframe: false,
                side: THREE.BackSide // Renderiza el interior de la esfera
            });

            backgroundSphereMesh = new THREE.Mesh(backgroundSphereGeometry, shaderMaterialBackground);
            scene.add(backgroundSphereMesh);

            // Manejo del redimensionamiento de la ventana
            window.addEventListener('resize', onWindowResize, false);
        }

        // Función para manejar el redimensionamiento de la ventana
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Configuración de Web Audio API y nativo ---
        async function initAudio() {
            // Detectar si es móvil y usar <audio> nativo
            useNativeAudio = /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent);
            let audioInitialized = false;
            function initAudioNodes() {
                if (useNativeAudio) return; // No inicializar WebAudio en móviles
                if (!audioInitialized) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    gainNode = audioContext.createGain();
                    analyser.fftSize = 256;
                    analyser.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    gainNode.gain.value = subtleVolumeControl.value;
                    subtleVolumeControl.addEventListener('input', (event) => {
                        gainNode.gain.value = event.target.value;
                    });
                    audioInitialized = true;
                }
            }
            // Botones para cambiar de audio/visualizador en controles sutiles
            const subtlePrevAudioButton = document.getElementById('subtlePrevAudioButton');
            const subtleNextAudioButton = document.getElementById('subtleNextAudioButton');
            subtlePrevAudioButton.addEventListener('click', async () => {
                if (audioFiles.length < 2) return;
                subtlePrevAudioButton.disabled = true;
                subtleNextAudioButton.disabled = true;
                // Limpiar eventos y pausar antes de cambiar
                if (useNativeAudio) {
                    nativeAudioPlayer.pause();
                    nativeAudioPlayer.onended = null;
                } else {
                    if (audioSource) {
                        audioSource.onended = null;
                        audioSource.stop();
                        audioSource.disconnect();
                    }
                }
                const trackList = document.getElementById('track-list');
                trackList.style.transition = 'opacity 0.4s';
                trackList.style.opacity = '0';
                setTimeout(async () => {
                    currentVisualizerIndex = (currentVisualizerIndex - 1 + audioFiles.length) % audioFiles.length;
                    await changeVisualizer(currentVisualizerIndex);
                    renderTrackList();
                    trackList.style.transition = 'opacity 0.4s';
                    trackList.style.opacity = '1';
                    subtlePrevAudioButton.disabled = false;
                    subtleNextAudioButton.disabled = false;
                }, 400);
            });
            subtleNextAudioButton.addEventListener('click', async () => {
                if (audioFiles.length < 2) return;
                subtlePrevAudioButton.disabled = true;
                subtleNextAudioButton.disabled = true;
                // Limpiar eventos y pausar antes de cambiar
                if (useNativeAudio) {
                    nativeAudioPlayer.pause();
                    nativeAudioPlayer.onended = null;
                    nativeAudioPlayer.currentTime = 0;
                } else {
                    if (audioSource) {
                        audioSource.onended = null;
                        audioSource.stop();
                        audioSource.disconnect();
                        isPlaying = false;
                        audioStartTime = 0;
                        audioPausedAt = 0;
                    }
                }
                const trackList = document.getElementById('track-list');
                trackList.style.transition = 'opacity 0.4s';
                trackList.style.opacity = '0';
                setTimeout(async () => {
                    currentVisualizerIndex = (currentVisualizerIndex + 1) % audioFiles.length;
                    await changeVisualizer(currentVisualizerIndex);
                    renderTrackList();
                    trackList.style.transition = 'opacity 0.4s';
                    trackList.style.opacity = '1';
                    subtlePrevAudioButton.disabled = false;
                    subtleNextAudioButton.disabled = false;
                }, 400);
            });
            try {
                // Cargar lista de audios e imágenes
                await loadMediaFiles();

                // Inicializar visualizador con el primer audio
                if (audioFiles.length > 0) {
                    if (useNativeAudio) {
                        nativeAudioPlayer.src = audioFiles[0];
                        nativeAudioPlayer.load();
                        await loadImagesForAudio(0);
                    } else {
                        initAudioNodes();
                        await loadAudioBuffer(audioFiles[0]);
                        await loadImagesForAudio(0);
                    }
                } else {
                    // monkeydev2.ddns.net('No se encontraron archivos de audio en la carpeta audios.', 5000);
                }

                // Event listeners para los botones de control de audio sutiles
                subtlePlayPauseButton.addEventListener('click', () => {
                    if (useNativeAudio) {
                        if (nativeAudioPlayer.paused) {
                            nativeAudioPlayer.play();
                            subtlePlayPauseButton.innerHTML = '<i class="fa-solid fa-pause"></i>';
                            isPlaying = true;
                            subtleControls.classList.add('visible');
                        } else {
                            nativeAudioPlayer.pause();
                            subtlePlayPauseButton.innerHTML = '<i class="fa-solid fa-play"></i>';
                            isPlaying = false;
                            subtleControls.classList.remove('visible');
                        }
                    } else {
                        initAudioNodes();
                        if (isPlaying) {
                            pauseAudio();
                        } else {
                            playAudio();
                        }
                    }
                });
                subtleStopButton.addEventListener('click', () => {
                    if (useNativeAudio) {
                        nativeAudioPlayer.pause();
                        nativeAudioPlayer.currentTime = 0;
                        subtlePlayPauseButton.innerHTML = '<i class="fa-solid fa-play"></i>';
                        isPlaying = false;
                        subtleControls.classList.remove('visible');
                    } else {
                        initAudioNodes();
                        stopAudio();
                    }
                });

                // Deshabilitado: no cambiar de tema con la rueda del mouse
                // window.addEventListener('wheel', ... );

                // Sincronizar barra de progreso y volumen con <audio> nativo
                if (useNativeAudio) {
                    nativeAudioPlayer.addEventListener('timeupdate', () => {
                        audioSeekBar.max = nativeAudioPlayer.duration || 1;
                        audioSeekBar.value = nativeAudioPlayer.currentTime;
                        audioCurrentTime.textContent = formatTime(nativeAudioPlayer.currentTime);
                        audioDuration.textContent = formatTime(nativeAudioPlayer.duration);
                    });
                    audioSeekBar.addEventListener('input', () => {
                        nativeAudioPlayer.currentTime = parseFloat(audioSeekBar.value);
                    });
                    subtleVolumeControl.addEventListener('input', (event) => {
                        nativeAudioPlayer.volume = event.target.value;
                    });
                    nativeAudioPlayer.volume = subtleVolumeControl.value;
                    // Reproducir siguiente canción automáticamente al terminar
                    nativeAudioPlayer.addEventListener('ended', async () => {
                        if (audioFiles.length > 1) {
                            currentVisualizerIndex = (currentVisualizerIndex + 1) % audioFiles.length;
                            await changeVisualizer(currentVisualizerIndex);
                        }
                    });
                }

            } catch (e) {
                console.error('Web Audio API no soportada en este navegador:', e);
                // showMessage('Tu navegador no soporta la Web Audio API. Intenta con Chrome o Firefox.', 8000);
                if (typeof playButton !== 'undefined') playButton.disabled = true;
                if (typeof pauseButton !== 'undefined') pauseButton.disabled = true;
                if (typeof stopButton !== 'undefined') stopButton.disabled = true;
                if (typeof volumeControl !== 'undefined') volumeControl.disabled = true;
                if (typeof subtlePlayButton !== 'undefined') subtlePlayButton.disabled = true;
                if (typeof subtlePauseButton !== 'undefined') subtlePauseButton.disabled = true;
                if (typeof subtleStopButton !== 'undefined') subtleStopButton.disabled = true;
                subtleVolumeControl.disabled = true;
            }
        }

        // Cargar lista de archivos de las carpetas audios e imagenes
        async function loadMediaFiles() {
            try {
                let audioResp = await fetch('audios.json');
                if (!audioResp.ok) {
                    showMessage('Error al cargar audios.json: ' + audioResp.statusText, 6000);
                    throw new Error('No se pudo cargar audios.json');
                }
                audioFiles = await audioResp.json();
                let imgResp = await fetch('imagenes.json');
                if (!imgResp.ok) {
                    showMessage('Error al cargar imagenes.json: ' + imgResp.statusText, 6000);
                    throw new Error('No se pudo cargar imagenes.json');
                }
                let imageFiles = await imgResp.json();
                // Para cada canción, asignar varias imágenes aleatorias (mínimo 3, máximo todas)
                imagesByAudio = audioFiles.map(() => {
                    // Siempre la primera imagen debe ser 'images/1.webp'
                    const firstImage = imageFiles.find(img => img.includes('1.webp')) || imageFiles[0];
                    // Mezclar aleatoriamente el resto, excluyendo '1.webp'
                    let restImages = imageFiles.filter(img => img !== firstImage).sort(() => Math.random() - 0.5);
                    // Seleccionar entre 2 y todas las restantes
                    let count = Math.max(2, Math.floor(Math.random() * (restImages.length - 1)) + 2);
                    return [firstImage, ...restImages.slice(0, count)];
                });
                renderTrackList();
            } catch (e) {
                showMessage('Error al cargar archivos de audios o imágenes: ' + e.message, 6000);
            }
        }

        // Cargar el buffer de audio para el visualizador actual
        async function loadAudioBuffer(audioUrl) {
            try {
                let resp = await fetch(audioUrl);
                if (!resp.ok) {
                    showMessage('Error al cargar el archivo de audio: ' + audioUrl + ' (' + resp.statusText + ')', 6000);
                    throw new Error('No se pudo cargar el archivo de audio');
                }
                let arrayBuffer = await resp.arrayBuffer();
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            } catch (e) {
                showMessage('Error al cargar el archivo de audio: ' + audioUrl + ' (' + e.message + ')', 6000);
            }
        }

        // Cargar imágenes para el visualizador actual
        async function loadImagesForAudio(index) {
            imageTextures = [];
            let files = imagesByAudio[index] || [];
            if (files.length === 0) {
                uniforms.u_hasImages.value = 0;
                uniforms.u_currentTexture.value = new THREE.DataTexture(new Uint8Array([255,255,255,255]), 1, 1, THREE.RGBAFormat);
                uniforms.u_currentTexture.value.needsUpdate = true;
                uniforms.u_nextTexture.value = uniforms.u_currentTexture.value;
                return;
            }
            const textureLoader = new THREE.TextureLoader();
            for (let i = 0; i < files.length; i++) {
                await new Promise((resolve, reject) => {
                    textureLoader.load(files[i], (texture) => {
                        imageTextures.push(texture);
                        resolve();
                    }, undefined, (err) => {
                        resolve();
                    });
                });
            }
            uniforms.u_hasImages.value = 1;
            currentTextureIndex = 0;
            uniforms.u_currentTexture.value = imageTextures[currentTextureIndex];
            nextTextureIndex = (currentTextureIndex + 1) % imageTextures.length;
            uniforms.u_nextTexture.value = imageTextures[nextTextureIndex];
            lastTransitionTime = 0;
            transitionState = TRANSITION_STATE.IDLE;
        }

        // Cambiar de visualizador (audio + imágenes)
        async function changeVisualizer(index) {
            if (useNativeAudio) {
                nativeAudioPlayer.pause();
                nativeAudioPlayer.onended = null;
                nativeAudioPlayer.src = audioFiles[index];
                nativeAudioPlayer.load();
                await loadImagesForAudio(index);
                nativeAudioPlayer.play();
                subtlePlayPauseButton.innerHTML = '<i class="fa-solid fa-pause"></i>';
                isPlaying = true;
                subtleControls.classList.add('visible');
                nativeAudioPlayer.onended = async () => {
                    // Solo avanzar si no fue por botón
                    if (audioFiles.length > 1) {
                        currentVisualizerIndex = (currentVisualizerIndex + 1) % audioFiles.length;
                        await changeVisualizer(currentVisualizerIndex);
                    }
                };
            } else {
                if (audioSource) {
                    audioSource.onended = null;
                    audioSource.stop();
                    audioSource.disconnect();
                }
                await loadAudioBuffer(audioFiles[index]);
                await loadImagesForAudio(index);
                // showMessage('Visualizador cambiado: ' + audioFiles[index].split('/').pop(), 2000);
                playAudio(); // <--- Asegura que la nueva canción inicie
                renderTrackList();
            }
        }

        // --- Barra de progreso y reposicionamiento ---
        const audioSeekBar = document.getElementById('audioSeekBar');
        const audioCurrentTime = document.getElementById('audioCurrentTime');
        const audioDuration = document.getElementById('audioDuration');
        let audioStartTime = 0;
        let audioPausedAt = 0;

        function updateAudioProgress() {
            if (useNativeAudio) return; // El nativo actualiza solo
            if (!audioSource || !audioBuffer || !isPlaying) return;
            let ctxTime = audioContext.currentTime;
            let elapsed = ctxTime - audioStartTime + audioPausedAt;
            let duration = audioBuffer.duration;
            if (elapsed > duration) elapsed = elapsed % duration;
            audioSeekBar.max = duration;
            audioSeekBar.value = elapsed;
            audioCurrentTime.textContent = formatTime(elapsed);
            audioDuration.textContent = formatTime(duration);
        }

        function formatTime(seconds) {
            seconds = Math.floor(seconds);
            let m = Math.floor(seconds / 60);
            let s = seconds % 60;
            return m + ':' + (s < 10 ? '0' : '') + s;
        }

        if (!useNativeAudio) {
            audioSeekBar.addEventListener('input', () => {
                if (!audioBuffer) return;
                let seekTo = parseFloat(audioSeekBar.value);
                if (audioSource) {
                    audioSource.onended = null;
                    audioSource.stop();
                    audioSource.disconnect();
                }
                audioSource = audioContext.createBufferSource();
                audioSource.buffer = audioBuffer;
                audioSource.connect(analyser);
                // audioSource.loop = true; // Quitar loop para que onended funcione
                audioStartTime = audioContext.currentTime;
                audioPausedAt = seekTo;
                audioSource.start(0, seekTo % audioBuffer.duration);
                isPlaying = true;
                audioSource.onended = async () => {
                    if (audioFiles.length > 1) {
                        if (audioSource) {
                            audioSource.onended = null;
                        }
                        currentVisualizerIndex = (currentVisualizerIndex + 1) % audioFiles.length;
                        await changeVisualizer(currentVisualizerIndex);
                    }
                };
            });
        }

        setInterval(updateAudioProgress, 500);

        // Función para reproducir el audio
        function playAudio() {
            if (useNativeAudio) {
                nativeAudioPlayer.play();
                subtlePlayPauseButton.innerHTML = '<i class="fa-solid fa-pause"></i>';
                isPlaying = true;
                subtleControls.classList.add('visible');
                return;
            }
            // Cambia el icono a pausa
            if (subtlePlayPauseButton) {
                subtlePlayPauseButton.innerHTML = '<i class="fa-solid fa-pause"></i>';
            }
            if (!audioBuffer) {
                showMessage('Por favor, carga un archivo de audio primero.', 4000);
                return;
            }

            if (audioContext.state === 'suspended') {
                audioContext.resume();
                audioStartTime = audioContext.currentTime;
            }

            if (audioSource) {
                stopAudio();
            }

            // Animación creepy con más variaciones y pausas entre ejecuciones
            let creepyActive = true;
            function creepyScaleLoop() {
                if (!isPlaying || !creepyActive) return;
                let baseScale = 1;
                let type = Math.floor(Math.random() * 7);
                let jump, newScale;
                switch(type) {
                    case 0: // Salto grande
                        jump = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 0.6 + 0.35);
                        newScale = baseScale + jump;
                        break;
                    case 1: // Oscilación rápida
                        jump = Math.sin(Date.now() * (Math.random() * 0.03 + 0.01)) * (Math.random() * 0.3 + 0.18);
                        newScale = baseScale + jump;
                        break;
                    case 2: // Pequeño temblor
                        jump = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 0.18 + 0.09);
                        newScale = baseScale + jump;
                        break;
                    case 3: // Rebote doble
                        jump = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 0.3 + 0.18);
                        newScale = baseScale + jump;
                        planeMesh.scale.set(newScale, newScale, newScale);
                        setTimeout(() => {
                            if (!isPlaying || !creepyActive) return;
                            let jump2 = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 0.22 + 0.11);
                            let newScale2 = baseScale + jump2;
                            planeMesh.scale.set(newScale2, newScale2, newScale2);
                            setTimeout(() => {
                                if (!isPlaying || !creepyActive) return;
                                planeMesh.scale.set(baseScale, baseScale, baseScale);
                                setTimeout(creepyScaleLoop, Math.random() * 700 + 350);
                            }, Math.random() * 160 + 80);
                        }, Math.random() * 160 + 80);
                        return;
                    case 4: // Parpadeo rápido
                        jump = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 0.45 + 0.22);
                        newScale = baseScale + jump;
                        planeMesh.scale.set(newScale, newScale, newScale);
                        setTimeout(() => {
                            if (!isPlaying || !creepyActive) return;
                            planeMesh.scale.set(baseScale, baseScale, baseScale);
                            setTimeout(creepyScaleLoop, Math.random() * 500 + 200);
                        }, Math.random() * 60 + 30);
                        return;
                    case 5: // Secuencia triple
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                if (!isPlaying || !creepyActive) return;
                                let jumpSeq = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 0.22 + 0.11);
                                let newScaleSeq = baseScale + jumpSeq;
                                planeMesh.scale.set(newScaleSeq, newScaleSeq, newScaleSeq);
                                setTimeout(() => {
                                    if (!isPlaying || !creepyActive) return;
                                    planeMesh.scale.set(baseScale, baseScale, baseScale);
                                }, Math.random() * 60 + 30);
                            }, i * (Math.random() * 120 + 60));
                        }
                        setTimeout(() => {
                            if (!isPlaying || !creepyActive) return;
                            setTimeout(creepyScaleLoop, Math.random() * 700 + 350);
                        }, 3 * (Math.random() * 120 + 60));
                        return;
                    case 6: // Pausa larga sin movimiento
                        planeMesh.scale.set(baseScale, baseScale, baseScale);
                        setTimeout(() => {
                            if (!isPlaying || !creepyActive) return;
                            setTimeout(creepyScaleLoop, Math.random() * 1200 + 600);
                        }, Math.random() * 200 + 100);
                        return;
                }
                planeMesh.scale.set(newScale, newScale, newScale);
                setTimeout(() => {
                    if (!isPlaying || !creepyActive) return;
                    planeMesh.scale.set(baseScale, baseScale, baseScale);
                    setTimeout(creepyScaleLoop, Math.random() * 500 + 200);
                }, Math.random() * 220 + 100);
            }
            planeMesh.scale.set(1, 1, 1);
            setTimeout(creepyScaleLoop, 200);
            planeMesh.__creepyActive = true;

            if (audioSource) {
                audioSource.onended = null;
                audioSource.stop();
                audioSource.disconnect();
            }
            audioSource = audioContext.createBufferSource();
            audioSource.buffer = audioBuffer;
            audioSource.connect(analyser);
            // audioSource.loop = true; // Quitar loop para que onended funcione
            audioStartTime = audioContext.currentTime;
            audioPausedAt = 0;
            audioSource.start(0);
            isPlaying = true;
            subtleControls.classList.add('visible');
            audioSource.onended = async () => {
                if (audioFiles.length > 1) {
                    if (audioSource) {
                        audioSource.onended = null;
                    }
                    currentVisualizerIndex = (currentVisualizerIndex + 1) % audioFiles.length;
                    await changeVisualizer(currentVisualizerIndex);
                }
            };
        }

        // Función para pausar el audio
        function pauseAudio() {
            // Cambia el icono a play
            if (subtlePlayPauseButton) {
                subtlePlayPauseButton.innerHTML = '<i class="fa-solid fa-play"></i>';
            }
            if (audioSource && isPlaying) {
                audioPausedAt += audioContext.currentTime - audioStartTime;
                audioContext.suspend();
                isPlaying = false;
                subtleControls.classList.remove('visible');
                // Detener animación creepy
                if (planeMesh) planeMesh.__creepyActive = false;
            }
        }

        // Función para detener el audio
        function stopAudio() {
            if (audioSource) {
                audioSource.stop();
                audioSource.disconnect();
                audioSource = null;
                isPlaying = false;
                audioContext.suspend();
                subtleControls.classList.remove('visible');
                audioStartTime = 0;
                audioPausedAt = 0;
                audioSeekBar.value = 0;
                audioCurrentTime.textContent = '0:00';
                audioDuration.textContent = '0:00';
                // Detener animación creepy y volver a escala pequeña al detener
                if (planeMesh) {
                    planeMesh.__creepyActive = false;
                    planeMesh.scale.set(0.4, 0.4, 0.4);
                }
            }
            // Reinicia el nivel de audio en los shaders cuando se detiene
            if (uniforms) {
                uniforms.u_audioLevel.value = 0.0;
                uniforms.u_transitionProgress.value = 0.0; // Reiniciar progreso de transición
                transitionState = TRANSITION_STATE.IDLE; // Reiniciar estado de transición
            }
            if (backgroundUniforms) {
                backgroundUniforms.u_audioLevel.value = 0.0;
            }
            // No mostrar mensaje de audio detenido
        }

        // --- Bucle de Animación ---
        function animate() {
            requestAnimationFrame(animate);

            controls.update(); // Actualiza los controles de órbita

            // Actualizar el tiempo global para los shaders
            uniforms.u_time.value += 0.01;
            backgroundUniforms.u_time.value += 0.01;

            let audioLevel = 0.0;
            if (useNativeAudio) {
                // En móviles, si el audio está reproduciéndose, usar un valor fijo para animaciones
                if (isPlaying && !nativeAudioPlayer.paused) {
                    audioLevel = 0.5 + 0.2 * Math.sin(uniforms.u_time.value * 1.5); // Oscila para dar vida
                    // Animación de rotación básica
                    planeMesh.rotation.z += 0.002;
                    planeMesh.rotation.x += 0.0007;
                } else {
                    // Si no se está reproduciendo, el nivel de audio debería tender a cero
                    if (uniforms.u_audioLevel.value > 0.01) {
                        audioLevel = uniforms.u_audioLevel.value * 0.95;
                    } else {
                        audioLevel = 0.0;
                    }
                }
            } else if (isPlaying && analyser) {
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteFrequencyData(dataArray); // Obtiene los datos de frecuencia

                // Calcula el nivel de audio promedio
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                let average = sum / bufferLength;
                // Normaliza el promedio a un valor entre 0 y 1
                audioLevel = average / 255.0;

                // Rotación del plano principal
                planeMesh.rotation.z += audioLevel * 0.003; // Menos rotación para más claridad
                planeMesh.rotation.x += audioLevel * 0.001; // Menos rotación para más claridad
            } else {
                // Si no se está reproduciendo, el nivel de audio debería tender a cero
                if (uniforms.u_audioLevel.value > 0.01) {
                    audioLevel = uniforms.u_audioLevel.value * 0.95; // Disminuye gradualmente
                } else {
                    audioLevel = 0.0;
                }
            }

            // Actualiza el uniforme u_audioLevel en ambos shaders
            uniforms.u_audioLevel.value = audioLevel;
            backgroundUniforms.u_audioLevel.value = audioLevel;

            // Lógica de transición de imágenes (Plano Principal)
            if (imageTextures.length > 1 && isPlaying) { // Solo transiciona si hay más de una imagen y se está reproduciendo
                lastTransitionTime += 0.01; // Incrementa el tiempo transcurrido

                switch (transitionState) {
                    case TRANSITION_STATE.IDLE:
                        if (lastTransitionTime >= minDisplayTime) {
                            // Iniciar una nueva transición
                            transitionState = TRANSITION_STATE.FADE_OUT;
                            lastTransitionTime = 0; // Reiniciar el tiempo para la fase de transición
                            // Seleccionar la siguiente imagen aleatoriamente, asegurándose de que no sea la misma
                            let newNextIndex;
                            do {
                                newNextIndex = Math.floor(Math.random() * imageTextures.length);
                            } while (newNextIndex === currentTextureIndex);
                            nextTextureIndex = newNextIndex;
                            uniforms.u_nextTexture.value = imageTextures[nextTextureIndex];
                        }
                        uniforms.u_transitionProgress.value = 0.0; // Asegurarse de que no haya transición visible
                        break;

                    case TRANSITION_STATE.FADE_OUT:
                        // Progreso de 0.0 a 1.0 para el fade out
                        let progressOut = lastTransitionTime / (transitionDuration / 2.0); // La mitad del tiempo para fade out
                        uniforms.u_transitionProgress.value = Math.min(1.0, progressOut);

                        if (uniforms.u_transitionProgress.value >= 1.0) {
                            // Completa el fade out, cambia la textura actual y empieza el fade in
                            currentTextureIndex = nextTextureIndex;
                            uniforms.u_currentTexture.value = imageTextures[currentTextureIndex];
                            transitionState = TRANSITION_STATE.FADE_IN;
                            lastTransitionTime = 0; // Reiniciar el tiempo para la fase de transición
                        }
                        break;

                    case TRANSITION_STATE.FADE_IN:
                        // Progreso de 1.0 a 0.0 para el fade in (o de 0.0 a 1.0 para la mezcla, luego invertir)
                        let progressIn = lastTransitionTime / (transitionDuration / 2.0); // La otra mitad del tiempo para fade in
                        uniforms.u_transitionProgress.value = Math.min(1.0, progressIn); // Esto es el factor de mezcla para la nueva imagen

                        if (uniforms.u_transitionProgress.value >= 1.0) {
                            // Transición completa, volver a estado IDLE
                            transitionState = TRANSITION_STATE.IDLE;
                            lastTransitionTime = 0; // Reiniciar el tiempo para el estado IDLE
                            uniforms.u_transitionProgress.value = 0.0; // Asegurarse de que la transición esté en 0 al final
                        }
                        break;
                }
            } else if (imageTextures.length === 1 && isPlaying && uniforms.u_hasImages.value === 1) {
                // Si solo hay una imagen, asegúrate de que sea la actual y no haya transición
                uniforms.u_currentTexture.value = imageTextures[0];
                uniforms.u_nextTexture.value = imageTextures[0]; // Apunta a sí misma para evitar errores
                uniforms.u_transitionProgress.value = 0.0;
                transitionState = TRANSITION_STATE.IDLE;
            } else {
                // Si no hay imágenes o no se está reproduciendo, asegura que no haya transición
                uniforms.u_transitionProgress.value = 0.0;
                transitionState = TRANSITION_STATE.IDLE;
            }

            renderer.render(scene, camera); // Renderiza la escena
        }

        // Inicializa todo cuando la ventana se carga
        window.onload = function() {
            initThreeJS();
            initAudio();
            animate(); // Inicia el bucle de animación
            subtleControls.classList.remove('visible'); // Asegura que los controles sutiles estén ocultos al inicio
            renderTrackList();
        };
    </script>
</body>
</html>
